package LaforteTraining.Ch3_TypesOfSorting.InsertSort;

/**
 * Сортировка методом вставки эффективна если массив ЧАСТИЧНО ОТСОРТИРОВАН!
 *
 * Маркер ставится на элемент, следующий после последнего элемента части от частично отсортированного массива.
 * Пример:
 *
 * 1 2 3 5 6 8 10 13 14 7 45 81 9 28 47
 * маркер будет 7. Он "выходит из шеренги" и попарно сравнивается
 * с 14
 * с 13
 * с 10
 * с 8
 * с 6, тут он больше, следовательно он встает на место следующее после 6, и все элементы после сдвигаются на один индекс
 *
 * Логика повторяется со следющим после частично отсортированного массива
 */
public class ArrayIns {
    private long[] a;                 // ref to array a
    private int nElems;               // number of data items
    //--------------------------------------------------------------
    public ArrayIns(int max)          // constructor
    {
        a = new long[max];                 // create the array
        nElems = 0;                        // no items yet
    }
    //--------------------------------------------------------------
    public void insert(long value)    // put element into array
    {
        a[nElems] = value;             // insert it
        nElems++;                      // increment size
    }
    //--------------------------------------------------------------
    public void display()             // displays array contents
    {
        for(int j=0; j<nElems; j++)       // for each element,
            System.out.print(a[j] + " ");  // display it
        System.out.println("");
    }

/*
Во внешнем цикле for счетчик начинает с позиции 1 и двигается вправо. Он отмечает крайний левый неотсортированный элемент.
Во внутреннем цикле while счетчик in начинает с позиции out и двигается влево - либо пока temp не станет меньше элемента массива,
 либо пока дальнейшее перемещение станет невозможным. При каждом проходе по циклу while следующий отсортированный элемент сдвигается
 на одну позицию вправо.
 */
    public void insertionSort()
    {
        int in, out;
        for(out=1; out < nElems; out++){    // out это маркер(красная футблока). Начинаем как бы с нуля, так как мы не значем где же конец частично отсортированного массив заканчивается
            long temp = a[out];            // вывести из шеренги элемент
            in = out;                      // начать сравнение и перемещение с индекса out(последнего элемента частично отсорти массива)
            while(in > 0 && a[in-1] >= temp) { // сравнивать пока не найден меньший, чем значение маркерованного элемента, или не дошли до конца(начала массива)
                a[in] = a[in-1];            // сдвинуть элемент вправо
                --in;                       // перейти к следующему индексу слева
            }
            a[in] = temp;                  // вставить выведенный из шеренги элемент
        }  // end for
    }  // end insertionSort()
}
/*
Алгоритм общий, то есть данные теоретически могут быт и не частично отсортированны, но тогда он теряет такую эффективность.
Если данные уже упорядочены, то условие цикла while никогда не будет истинным, следовательно просто переход к команде во внешнем цикле.
Если обратная сортировка, по убыванию, то скорость не быстрее пузырьковой сортировки.
Если данные частично упорядочены, то есть с небольшими отклонениями,  то выполняется сортировка почти за время O(N) - эффективно.
 */